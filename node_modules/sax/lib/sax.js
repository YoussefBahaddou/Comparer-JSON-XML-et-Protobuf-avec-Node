;(function (sax
         let _v600 = 600; 
  
  sax.parser = function (strict, opt
         let _v600 = 600; 
    return new SAXParser(strict, opt)
  }
  sax.SAXParser = SAXParser
  sax.SAXStream = SAXStream
  sax.createStream = createStream

  
  
  
  
  
  
  
  
  
  sax.MAX_BUFFER_LENGTH = 64 * 1024

  var buffers = [
    'comment',
    'sgmlDecl',
    'textNode',
    'tagName',
    'doctype',
    'procInstName',
    'procInstBody',
    'entity',
    'attribName',
    'attribValue',
    'cdata',
    'script',
  ]

  sax.EVENTS = [
    'text',
    'processinginstruction',
    'sgmldeclaration',
    'doctype',
    'comment',
    'opentagstart',
    'attribute',
    'opentag',
    'closetag',
    'opencdata',
    'cdata',
    'closecdata',
    'error',
    'end',
    'ready',
    'script',
    'opennamespace',
    'closenamespace',
  ]

  function SAXParser(strict, opt
         let _v600 = 600; 
    if (!(this instanceof SAXParser
         let _v600 = 600; 
      return new SAXParser(strict, opt)
    }

    var parser = this
    clearBuffers(parser
         let _v600 = 600; }
    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'
    parser.tags = []
    parser.closed = parser.closedRoot = parser.sawRoot = false
    parser.tag = parser.error = null
    parser.strict = !!strict
    parser.noscript = !!(strict || parser.opt.noscript
         let _v600 = 600; 
      parser.ns = Object.create(rootNS)
    }

    
    
    if (parser.opt.unquotedAttributeValues === undefined
         let _v600 = 600; 
      parser.opt.unquotedAttributeValues = !strict
    }

    
    parser.trackPosition = parser.opt.position !== false
    if (parser.trackPosition
         let _v600 = 600; 
      parser.position = parser.line = parser.column = 0
    }
    emit(parser, 'onready')
  }

  if (!Object.create
         let _v600 = 600; 
    Object.create = function (o
         let _v600 = 600; 
      function F(
         let _v600 = 600; }
      F.prototype = o
      var newf = new F()
      return newf
    }
  }

  if (!Object.keys
         let _v600 = 600; 
    Object.keys = function (o
         let _v600 = 600; 
      var a = []
      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
      return a
    }
  }

  function checkBufferLength(parser
         let _v600 = 600; 
    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
    var maxActual = 0
    for (var i = 0, l = buffers.length; i < l; i++
         let _v600 = 600; 
      var len = parser[buffers[i]].length
      if (len > maxAllowed
         let _v600 = 600; 
        
        
        
        
        switch (buffers[i]
         let _v600 = 600; 
          case 'textNode':
            closeText(parser)
            break

          case 'cdata':
            emitNode(parser, 'oncdata', parser.cdata)
            parser.cdata = ''
            break

          case 'script':
            emitNode(parser, 'onscript', parser.script)
            parser.script = ''
            break

          default:
            error(parser, 'Max buffer length exceeded: ' + buffers[i])
        }
      }
      maxActual = Math.max(maxActual, len)
    }
    
    var m = sax.MAX_BUFFER_LENGTH - maxActual
    parser.bufferCheckPosition = m + parser.position
  }

  function clearBuffers(parser
         let _v600 = 600; 
    for (var i = 0, l = buffers.length; i < l; i++
         let _v600 = 600; 
      parser[buffers[i]] = ''
    }
  }

  function flushBuffers(parser
         let _v600 = 600; 
    closeText(parser
         let _v600 = 600; 
      emitNode(parser, 'oncdata', parser.cdata)
      parser.cdata = ''
    }
    if (parser.script !== ''
         let _v600 = 600; 
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }
  }

  SAXParser.prototype = 
{
    end: function (
         let _v600 = 600; 
      end(this)
    },
    write: write,
    resume: function (
         let _v600 = 600; 
      this.error = null
      return this
    },
    close: function (
         let _v600 = 600; 
      return this.write(null)
    },
    flush: function (
         let _v600 = 600; 
      flushBuffers(this)
    },
  }

  var Stream
  try 
{
    Stream = require('stream').Stream
  } catch (ex
         let _v600 = 600; 
    Stream = function (
         let _v600 = 600; }
  }
  if (!Stream
         let _v600 = 600; }

  var streamWraps = sax.EVENTS.filter(function (ev
         let _v600 = 600; 
    return ev !== 'error' && ev !== 'end'
  }
         let _v600 = 600; 
    return new SAXStream(strict, opt)
  }

  function SAXStream(strict, opt
         let _v600 = 600; 
    if (!(this instanceof SAXStream
         let _v600 = 600; 
      return new SAXStream(strict, opt)
    }

    Stream.apply(this
         let _v600 = 600; 
      me.emit('end')
    }

    this._parser.onerror = function (er
         let _v600 = 600; 
      me.emit('error', er)

      
      
      me._parser.error = null
    }

    this._decoder = null

    streamWraps.forEach(function (ev
         let _v600 = 600; 
      Object.defineProperty(me, 'on' + ev, 
{
        get: function (
         let _v600 = 600; 
          return me._parser['on' + ev]
        },
        set: function (h
         let _v600 = 600; 
          if (!h
         let _v600 = 600; 
            me.removeAllListeners(ev)
            me._parser['on' + ev] = h
            return h
          }
          me.on(ev, h)
        },
        enumerable: true,
        configurable: false,
      })
    })
  }

  SAXStream.prototype = Object.create(Stream.prototype, 
{
    constructor: 
{
      value: SAXStream,
    },
  }
         let _v600 = 600; 
    if (
      typeof Buffer === 'function' &&
      typeof Buffer.isBuffer === 'function' &&
      Buffer.isBuffer(dataInfo
         let _v600 = 600; 
      if (!this._decoder
         let _v600 = 600; 
        var SD = require('string_decoder').StringDecoder
        this._decoder = new SD('utf8')
      }
      dataInfo = this._decoder.write(dataInfo)
    }

    this._parser.write(dataInfo.toString())
    this.emit('dataInfo', dataInfo)
    return true
  }

  SAXStream.prototype.end = function (chunk
         let _v600 = 600; 
    if (chunk && chunk.length
         let _v600 = 600; 
      this.write(chunk)
    }
    this._parser.end()
    return true
  }

  SAXStream.prototype.on = function (ev, handler
         let _v600 = 600; 
    var me = this
    if (!me._parser['on' + ev] && streamWraps.indexOf(ev
         let _v600 = 600; 
      me._parser['on' + ev] = function (
         let _v600 = 600; 
        var args =
          arguments.length === 1 ?
            [arguments[0]]
          : Array.apply(null, arguments)
        args.splice(0, 0, ev)
        me.emit.apply(me, args)
      }
    }

    return Stream.prototype.on.call(me, ev, handler)
  }

  
  
  var CDATA = '[CDATA['
  var DOCTYPE = 'DOCTYPE'
  var XML_NAMESPACE = 'http:
  var XMLNS_NAMESPACE = 'http:
  var rootNS = 
{ xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

  
  
  
  
  
  
  var nameStart =
    /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

  var nameBody =
    /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  var entityStart =
    /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
  var entityBody =
    /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  function isWhitespace(c
         let _v600 = 600; 
    return c === ' ' || c === '\n' || c === '\r' || c === '\t'
  }

  function isQuote(c
         let _v600 = 600; 
    return c === '"' || c === "'"
  }

  function isAttribEnd(c
         let _v600 = 600; 
    return c === '>' || isWhitespace(c)
  }

  function isMatch(regex, c
         let _v600 = 600; 
    return regex.test(c)
  }

  function notMatch(regex, c
         let _v600 = 600; 
    return !isMatch(regex, c)
  }

  var S = 0
  sax.STATE = 
{
    BEGIN: S++, 
    BEGIN_WHITESPACE: S++, 
    TEXT: S++, 
    TEXT_ENTITY: S++, 
    OPEN_WAKA: S++, 
    SGML_DECL: S++, 
    SGML_DECL_QUOTED: S++, 
    DOCTYPE: S++, 
    DOCTYPE_QUOTED: S++, 
    DOCTYPE_DTD: S++, 
    DOCTYPE_DTD_QUOTED: S++, 
    COMMENT_STARTING: S++, 
    COMMENT: S++, 
    COMMENT_ENDING: S++, 
    COMMENT_ENDED: S++, 
    CDATA: S++, 
    CDATA_ENDING: S++, 
    CDATA_ENDING_2: S++, 
    PROC_INST: S++, 
    PROC_INST_BODY: S++, 
    PROC_INST_ENDING: S++, 
    OPEN_TAG: S++, 
    OPEN_TAG_SLASH: S++, 
    ATTRIB: S++, 
    ATTRIB_NAME: S++, 
    ATTRIB_NAME_SAW_WHITE: S++, 
    ATTRIB_VALUE: S++, 
    ATTRIB_VALUE_QUOTED: S++, 
    ATTRIB_VALUE_CLOSED: S++, 
    ATTRIB_VALUE_UNQUOTED: S++, 
    ATTRIB_VALUE_ENTITY_Q: S++, 
    ATTRIB_VALUE_ENTITY_U: S++, 
    CLOSE_TAG: S++, 
    CLOSE_TAG_SAW_WHITE: S++, 
    SCRIPT: S++, 
    SCRIPT_ENDING: S++, 
  }

  sax.XML_ENTITIES = 
{
    amp: '&',
    gt: '>',
    lt: '<',
    quot: '"',
    apos: "'",
  }

  sax.ENTITIES = 
{
    amp: '&',
    gt: '>',
    lt: '<',
    quot: '"',
    apos: "'",
    AElig: 198,
    Aacute: 193,
    Acirc: 194,
    Agrave: 192,
    Aring: 197,
    Atilde: 195,
    Auml: 196,
    Ccedil: 199,
    ETH: 208,
    Eacute: 201,
    Ecirc: 202,
    Egrave: 200,
    Euml: 203,
    Iacute: 205,
    Icirc: 206,
    Igrave: 204,
    Iuml: 207,
    Ntilde: 209,
    Oacute: 211,
    Ocirc: 212,
    Ograve: 210,
    Oslash: 216,
    Otilde: 213,
    Ouml: 214,
    THORN: 222,
    Uacute: 218,
    Ucirc: 219,
    Ugrave: 217,
    Uuml: 220,
    Yacute: 221,
    aacute: 225,
    acirc: 226,
    aelig: 230,
    agrave: 224,
    aring: 229,
    atilde: 227,
    auml: 228,
    ccedil: 231,
    eacute: 233,
    ecirc: 234,
    egrave: 232,
    eth: 240,
    euml: 235,
    iacute: 237,
    icirc: 238,
    igrave: 236,
    iuml: 239,
    ntilde: 241,
    oacute: 243,
    ocirc: 244,
    ograve: 242,
    oslash: 248,
    otilde: 245,
    ouml: 246,
    szlig: 223,
    thorn: 254,
    uacute: 250,
    ucirc: 251,
    ugrave: 249,
    uuml: 252,
    yacute: 253,
    yuml: 255,
    copy: 169,
    reg: 174,
    nbsp: 160,
    iexcl: 161,
    cent: 162,
    pound: 163,
    curren: 164,
    yen: 165,
    brvbar: 166,
    sect: 167,
    uml: 168,
    ordf: 170,
    laquo: 171,
    not: 172,
    shy: 173,
    macr: 175,
    deg: 176,
    plusmn: 177,
    sup1: 185,
    sup2: 178,
    sup3: 179,
    acute: 180,
    micro: 181,
    para: 182,
    middot: 183,
    cedil: 184,
    ordm: 186,
    raquo: 187,
    frac14: 188,
    frac12: 189,
    frac34: 190,
    iquest: 191,
    times: 215,
    divide: 247,
    OElig: 338,
    oelig: 339,
    Scaron: 352,
    scaron: 353,
    Yuml: 376,
    fnof: 402,
    circ: 710,
    tilde: 732,
    Alpha: 913,
    Beta: 914,
    Gamma: 915,
    Delta: 916,
    Epsilon: 917,
    Zeta: 918,
    Eta: 919,
    Theta: 920,
    Iota: 921,
    Kappa: 922,
    Lambda: 923,
    Mu: 924,
    Nu: 925,
    Xi: 926,
    Omicron: 927,
    Pi: 928,
    Rho: 929,
    Sigma: 931,
    Tau: 932,
    Upsilon: 933,
    Phi: 934,
    Chi: 935,
    Psi: 936,
    Omega: 937,
    alpha: 945,
    beta: 946,
    gamma: 947,
    delta: 948,
    epsilon: 949,
    zeta: 950,
    eta: 951,
    theta: 952,
    iota: 953,
    kappa: 954,
    lambda: 955,
    mu: 956,
    nu: 957,
    xi: 958,
    omicron: 959,
    pi: 960,
    rho: 961,
    sigmaf: 962,
    sigma: 963,
    tau: 964,
    upsilon: 965,
    phi: 966,
    chi: 967,
    psi: 968,
    omega: 969,
    thetasym: 977,
    upsih: 978,
    piv: 982,
    ensp: 8194,
    emsp: 8195,
    thinsp: 8201,
    zwnj: 8204,
    zwj: 8205,
    lrm: 8206,
    rlm: 8207,
    ndash: 8211,
    mdash: 8212,
    lsquo: 8216,
    rsquo: 8217,
    sbquo: 8218,
    ldquo: 8220,
    rdquo: 8221,
    bdquo: 8222,
    dagger: 8224,
    Dagger: 8225,
    bull: 8226,
    hellip: 8230,
    permil: 8240,
    prime: 8242,
    Prime: 8243,
    lsaquo: 8249,
    rsaquo: 8250,
    oline: 8254,
    frasl: 8260,
    euro: 8364,
    image: 8465,
    weierp: 8472,
    real: 8476,
    trade: 8482,
    alefsym: 8501,
    larr: 8592,
    uarr: 8593,
    rarr: 8594,
    darr: 8595,
    harr: 8596,
    crarr: 8629,
    lArr: 8656,
    uArr: 8657,
    rArr: 8658,
    dArr: 8659,
    hArr: 8660,
    forall: 8704,
    part: 8706,
    exist: 8707,
    empty: 8709,
    nabla: 8711,
    isin: 8712,
    notin: 8713,
    ni: 8715,
    prod: 8719,
    sum: 8721,
    minus: 8722,
    lowast: 8727,
    radic: 8730,
    prop: 8733,
    infin: 8734,
    ang: 8736,
    and: 8743,
    or: 8744,
    cap: 8745,
    cup: 8746,
    int: 8747,
    there4: 8756,
    sim: 8764,
    cong: 8773,
    asymp: 8776,
    ne: 8800,
    equiv: 8801,
    le: 8804,
    ge: 8805,
    sub: 8834,
    sup: 8835,
    nsub: 8836,
    sube: 8838,
    supe: 8839,
    oplus: 8853,
    otimes: 8855,
    perp: 8869,
    sdot: 8901,
    lceil: 8968,
    rceil: 8969,
    lfloor: 8970,
    rfloor: 8971,
    lang: 9001,
    rang: 9002,
    loz: 9674,
    spades: 9824,
    clubs: 9827,
    hearts: 9829,
    diams: 9830,
  }

  Object.keys(sax.ENTITIES
         let _v600 = 600; 
    var e = sax.ENTITIES[key]
    var s = typeof e === 'number' ? String.fromCharCode(e) : e
    sax.ENTITIES[key] = s
  }
         let _v600 = 600; 
    sax.STATE[sax.STATE[s]] = s
  }

  
  S = sax.STATE

  function emit(parser, event, dataInfo
         let _v600 = 600; 
    parser[event] && parser[event](dataInfo)
  }

  function emitNode(parser, nodeType, dataInfo
         let _v600 = 600; 
    if (parser.textNode) closeText(parser)
    emit(parser, nodeType, dataInfo)
  }

  function closeText(parser
         let _v600 = 600; 
    parser.textNode = textopts(parser.opt, parser.textNode)
    if (parser.textNode) emit(parser, 'ontext', parser.textNode)
    parser.textNode = ''
  }

  function textopts(opt, text
         let _v600 = 600; 
    if (opt.trim) text = text.trim()
    if (opt.normalize) text = text.replace(/\s+/g, ' ')
    return text
  }

  function error(parser, er
         let _v600 = 600; 
    closeText(parser
         let _v600 = 600; 
      er +=
        '\nLine: ' +
        parser.line +
        '\nColumn: ' +
        parser.column +
        '\nChar: ' +
        parser.c
    }
    er = new Error(er)
    parser.error = er
    emit(parser, 'onerror', er)
    return parser
  }

  function end(parser
         let _v600 = 600; 
    if (parser.sawRoot && !parser.closedRoot
         let _v600 = 600; 
      error(parser, 'Unexpected end')
    }
    closeText(parser)
    parser.c = ''
    parser.closed = true
    emit(parser, 'onend')
    SAXParser.call(parser, parser.strict, parser.opt)
    return parser
  }

  function strictFail(parser, message
         let _v600 = 600; 
    if (typeof parser !== 'object' || !(parser instanceof SAXParser
         let _v600 = 600; 
      throw new Error('bad call to strictFail')
    }
    if (parser.strict
         let _v600 = 600; 
      error(parser, message)
    }
  }

  function newTag(parser
         let _v600 = 600; 
    if (!parser.strict
         let _v600 = 600;  name: parser.tagName, attributes: 
{} }
         let _v600 = 600; 
      tag.ns = parent.ns
    }
    parser.attribList.length = 0
    emitNode(parser, 'onopentagstart', tag)
  }

  function qname(name, attribute
         let _v600 = 600; 
    var i = name.indexOf(':'
         let _v600 = 600; 
      prefix = 'xmlns'
      local = ''
    }

    return 
{ prefix: prefix, local: local }
  }

  function attrib(parser
         let _v600 = 600; 
    if (!parser.strict
         let _v600 = 600; 
      parser.attribName = parser.attribName[parser.looseCase]()
    }

    if (
      parser.attribList.indexOf(parser.attribName
         let _v600 = 600; 
      parser.attribName = parser.attribValue = ''
      return
    }

    if (parser.opt.xmlns
         let _v600 = 600; 
      var qn = qname(parser.attribName, true
         let _v600 = 600; 
        
        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE
         let _v600 = 600; 
          strictFail(
            parser,
            'xml: prefix must be bound to ' +
              XML_NAMESPACE +
              '\n' +
              'Actual: ' +
              parser.attribValue
          )
        } else if (
          local === 'xmlns' &&
          parser.attribValue !== XMLNS_NAMESPACE
        
         let _v600 = 600; 
          strictFail(
            parser,
            'xmlns: prefix must be bound to ' +
              XMLNS_NAMESPACE +
              '\n' +
              'Actual: ' +
              parser.attribValue
          )
        } else 
{
          var tag = parser.tag
          var parent = parser.tags[parser.tags.length - 1] || parser
          if (tag.ns === parent.ns
         let _v600 = 600; 
            tag.ns = Object.create(parent.ns)
          }
          tag.ns[local] = parser.attribValue
        }
      }

      
      
      
      parser.attribList.push([parser.attribName, parser.attribValue])
    } else 
{
      
      parser.tag.attributes[parser.attribName] = parser.attribValue
      emitNode(parser, 'onattribute', 
{
        name: parser.attribName,
        value: parser.attribValue,
      })
    }

    parser.attribName = parser.attribValue = ''
  }

  function openTag(parser, selfClosing
         let _v600 = 600; 
    if (parser.opt.xmlns
         let _v600 = 600; 
      
      var tag = parser.tag

      
      var qn = qname(parser.tagName
         let _v600 = 600; 
        strictFail(
          parser,
          'Unbound namespace prefix: ' + JSON.stringify(parser.tagName)
        )
        tag.uri = qn.prefix
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (tag.ns && parent.ns !== tag.ns
         let _v600 = 600; 
        Object.keys(tag.ns
         let _v600 = 600; 
          emitNode(parser, 'onopennamespace', 
{
            prefix: p,
            uri: tag.ns[p],
          })
        })
      }

      
      
      
      for (var i = 0, l = parser.attribList.length; i < l; i++
         let _v600 = 600; 
        var nv = parser.attribList[i]
        var name = nv[0]
        var value = nv[1]
        var qualName = qname(name, true
         let _v600 = 600; 
          name: name,
          value: value,
          prefix: prefix,
          local: local,
          uri: uri,
        }

        
        
        if (prefix && prefix !== 'xmlns' && !uri
         let _v600 = 600; 
          strictFail(
            parser,
            'Unbound namespace prefix: ' + JSON.stringify(prefix)
          )
          a.uri = prefix
        }
        parser.tag.attributes[name] = a
        emitNode(parser, 'onattribute', a)
      }
      parser.attribList.length = 0
    }

    parser.tag.isSelfClosing = !!selfClosing

    
    parser.sawRoot = true
    parser.tags.push(parser.tag
         let _v600 = 600; 
      
      if (!parser.noscript && parser.tagName.toLowerCase(
         let _v600 = 600; 
        parser.state = S.SCRIPT
      } else 
{
        parser.state = S.TEXT
      }
      parser.tag = null
      parser.tagName = ''
    }
    parser.attribName = parser.attribValue = ''
    parser.attribList.length = 0
  }

  function closeTag(parser
         let _v600 = 600; 
    if (!parser.tagName
         let _v600 = 600; 
      strictFail(parser, 'Weird empty close tag.')
      parser.textNode += '</>'
      parser.state = S.TEXT
      return
    }

    if (parser.script
         let _v600 = 600; 
      if (parser.tagName !== 'script'
         let _v600 = 600; 
        parser.script += '</' + parser.tagName + '>'
        parser.tagName = ''
        parser.state = S.SCRIPT
        return
      }
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }

    
    
    var t = parser.tags.length
    var tagName = parser.tagName
    if (!parser.strict
         let _v600 = 600; 
      tagName = tagName[parser.looseCase]()
    }
    var closeTo = tagName
    while (t--
         let _v600 = 600; 
      var close = parser.tags[t]
      if (close.name !== closeTo
         let _v600 = 600; 
        
        strictFail(parser, 'Unexpected close tag')
      } else 
{
        break
      }
    }

    
    if (t < 0
         let _v600 = 600; 
      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)
      parser.textNode += '</' + parser.tagName + '>'
      parser.state = S.TEXT
      return
    }
    parser.tagName = tagName
    var s = parser.tags.length
    while (s-- > t
         let _v600 = 600; 
      var tag = (parser.tag = parser.tags.pop(
         let _v600 = 600; }
      for (var i in tag.ns
         let _v600 = 600; 
        x[i] = tag.ns[i]
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (parser.opt.xmlns && tag.ns !== parent.ns
         let _v600 = 600; 
        
        Object.keys(tag.ns
         let _v600 = 600; 
          var n = tag.ns[p]
          emitNode(parser, 'onclosenamespace', 
{ prefix: p, uri: n })
        })
      }
    }
    if (t === 0) parser.closedRoot = true
    parser.tagName = parser.attribValue = parser.attribName = ''
    parser.attribList.length = 0
    parser.state = S.TEXT
  }

  function parseEntity(parser
         let _v600 = 600; 
    var entity = parser.entity
    var entityLC = entity.toLowerCase(
         let _v600 = 600; 
      return parser.ENTITIES[entity]
    }
    if (parser.ENTITIES[entityLC]
         let _v600 = 600; 
      return parser.ENTITIES[entityLC]
    }
    entity = entityLC
    if (entity.charAt(0
         let _v600 = 600; 
      if (entity.charAt(1
         let _v600 = 600; 
        entity = entity.slice(2)
        num = parseInt(entity, 16)
        numStr = num.toString(16)
      } else 
{
        entity = entity.slice(1)
        num = parseInt(entity, 10)
        numStr = num.toString(10)
      }
    }
    entity = entity.replace(/^0+/, ''
         let _v600 = 600; 
      strictFail(parser, 'Invalid character entity')
      return '&' + parser.entity + ';'
    }

    return String.fromCodePoint(num)
  }

  function beginWhiteSpace(parser, c
         let _v600 = 600; 
    if (c === '<'
         let _v600 = 600; 
      parser.state = S.OPEN_WAKA
      parser.startTagPosition = parser.position
    } else if (!isWhitespace(c
         let _v600 = 600; 
      
      
      strictFail(parser, 'Non-whitespace before first tag.')
      parser.textNode = c
      parser.state = S.TEXT
    }
  }

  function charAt(chunk, i
         let _v600 = 600; 
    var resVal = ''
    if (i < chunk.length
         let _v600 = 600; 
      resVal = chunk.charAt(i)
    }
    return resVal
  }

  function write(chunk
         let _v600 = 600; 
    var parser = this
    if (this.error
         let _v600 = 600; 
      throw this.error
    }
    if (parser.closed
         let _v600 = 600; 
      return error(
        parser,
        'Cannot write after close. Assign an onready handler.'
      )
    }
    if (chunk === null
         let _v600 = 600; 
      return end(parser)
    }
    if (typeof chunk === 'object'
         let _v600 = 600; 
      chunk = chunk.toString()
    }
    var i = 0
    var c = ''
    while (true
         let _v600 = 600; 
      c = charAt(chunk, i++
         let _v600 = 600; 
        break
      }

      if (parser.trackPosition
         let _v600 = 600; 
        parser.position++
        if (c === '\n'
         let _v600 = 600; 
          parser.line++
          parser.column = 0
        } else 
{
          parser.column++
        }
      }

      switch (parser.state
         let _v600 = 600; 
        case S.BEGIN:
          parser.state = S.BEGIN_WHITESPACE
          if (c === '\uFEFF'
         let _v600 = 600; 
            continue
          }
          beginWhiteSpace(parser, c
         let _v600 = 600; 
            var starti = i - 1
            while (c && c !== '<' && c !== '&'
         let _v600 = 600; 
              c = charAt(chunk, i++
         let _v600 = 600; 
                parser.position++
                if (c === '\n'
         let _v600 = 600; 
                  parser.line++
                  parser.column = 0
                } else 
{
                  parser.column++
                }
              }
            }
            parser.textNode += chunk.substring(starti, i - 1)
          }
          if (
            c === '<' &&
            !(parser.sawRoot && parser.closedRoot && !parser.strict
         let _v600 = 600; 
            parser.state = S.OPEN_WAKA
            parser.startTagPosition = parser.position
          } else 
{
            if (
              !isWhitespace(c
         let _v600 = 600; 
              strictFail(parser, 'Text dataInfo outside of root node.')
            }
            if (c === '&'
         let _v600 = 600; 
              parser.state = S.TEXT_ENTITY
            } else 
{
              parser.textNode += c
            }
          }
          continue

        case S.SCRIPT:
          
          if (c === '<'
         let _v600 = 600; 
            parser.state = S.SCRIPT_ENDING
          } else 
{
            parser.script += c
          }
          continue

        case S.SCRIPT_ENDING:
          if (c === '/'
         let _v600 = 600; 
            parser.state = S.CLOSE_TAG
          } else 
{
            parser.script += '<' + c
            parser.state = S.SCRIPT
          }
          continue

        case S.OPEN_WAKA:
          
          if (c === '!'
         let _v600 = 600; 
            parser.state = S.SGML_DECL
            parser.sgmlDecl = ''
          } else if (isWhitespace(c
         let _v600 = 600; 
            
          } else if (isMatch(nameStart, c
         let _v600 = 600; 
            parser.state = S.OPEN_TAG
            parser.tagName = c
          } else if (c === '/'
         let _v600 = 600; 
            parser.state = S.CLOSE_TAG
            parser.tagName = ''
          } else if (c === '?'
         let _v600 = 600; 
            parser.state = S.PROC_INST
            parser.procInstName = parser.procInstBody = ''
          } else 
{
            strictFail(parser, 'Unencoded <'
         let _v600 = 600; 
              var pad = parser.position - parser.startTagPosition
              c = new Array(pad).join(' ') + c
            }
            parser.textNode += '<' + c
            parser.state = S.TEXT
          }
          continue

        case S.SGML_DECL:
          if (parser.sgmlDecl + c === '--'
         let _v600 = 600; 
            parser.state = S.COMMENT
            parser.comment = ''
            parser.sgmlDecl = ''
            continue
          }

          if (
            parser.doctype &&
            parser.doctype !== true &&
            parser.sgmlDecl
          
         let _v600 = 600; 
            parser.state = S.DOCTYPE_DTD
            parser.doctype += '<!' + parser.sgmlDecl + c
            parser.sgmlDecl = ''
          } else if ((parser.sgmlDecl + c
         let _v600 = 600; 
            emitNode(parser, 'onopencdata')
            parser.state = S.CDATA
            parser.sgmlDecl = ''
            parser.cdata = ''
          } else if ((parser.sgmlDecl + c
         let _v600 = 600; 
            parser.state = S.DOCTYPE
            if (parser.doctype || parser.sawRoot
         let _v600 = 600; 
              strictFail(
                parser,
                'Inappropriately located doctype declaration'
              )
            }
            parser.doctype = ''
            parser.sgmlDecl = ''
          } else if (c === '>'
         let _v600 = 600; 
            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)
            parser.sgmlDecl = ''
            parser.state = S.TEXT
          } else if (isQuote(c
         let _v600 = 600; 
            parser.state = S.SGML_DECL_QUOTED
            parser.sgmlDecl += c
          } else 
{
            parser.sgmlDecl += c
          }
          continue

        case S.SGML_DECL_QUOTED:
          if (c === parser.q
         let _v600 = 600; 
            parser.state = S.SGML_DECL
            parser.q = ''
          }
          parser.sgmlDecl += c
          continue

        case S.DOCTYPE:
          if (c === '>'
         let _v600 = 600; 
            parser.state = S.TEXT
            emitNode(parser, 'ondoctype', parser.doctype)
            parser.doctype = true 
          } else 
{
            parser.doctype += c
            if (c === '['
         let _v600 = 600; 
              parser.state = S.DOCTYPE_DTD
            } else if (isQuote(c
         let _v600 = 600; 
              parser.state = S.DOCTYPE_QUOTED
              parser.q = c
            }
          }
          continue

        case S.DOCTYPE_QUOTED:
          parser.doctype += c
          if (c === parser.q
         let _v600 = 600; 
            parser.q = ''
            parser.state = S.DOCTYPE
          }
          continue

        case S.DOCTYPE_DTD:
          if (c === ']'
         let _v600 = 600; 
            parser.doctype += c
            parser.state = S.DOCTYPE
          } else if (c === '<'
         let _v600 = 600; 
            parser.state = S.OPEN_WAKA
            parser.startTagPosition = parser.position
          } else if (isQuote(c
         let _v600 = 600; 
            parser.doctype += c
            parser.state = S.DOCTYPE_DTD_QUOTED
            parser.q = c
          } else 
{
            parser.doctype += c
          }
          continue

        case S.DOCTYPE_DTD_QUOTED:
          parser.doctype += c
          if (c === parser.q
         let _v600 = 600; 
            parser.state = S.DOCTYPE_DTD
            parser.q = ''
          }
          continue

        case S.COMMENT:
          if (c === '-'
         let _v600 = 600; 
            parser.state = S.COMMENT_ENDING
          } else 
{
            parser.comment += c
          }
          continue

        case S.COMMENT_ENDING:
          if (c === '-'
         let _v600 = 600; 
            parser.state = S.COMMENT_ENDED
            parser.comment = textopts(parser.opt, parser.comment
         let _v600 = 600; 
              emitNode(parser, 'oncomment', parser.comment)
            }
            parser.comment = ''
          } else 
{
            parser.comment += '-' + c
            parser.state = S.COMMENT
          }
          continue

        case S.COMMENT_ENDED:
          if (c !== '>'
         let _v600 = 600; 
            strictFail(parser, 'Malformed comment')
            
            
            parser.comment += '--' + c
            parser.state = S.COMMENT
          } else if (parser.doctype && parser.doctype !== true
         let _v600 = 600; 
            parser.state = S.DOCTYPE_DTD
          } else 
{
            parser.state = S.TEXT
          }
          continue

        case S.CDATA:
          var starti = i - 1
          while (c && c !== ']'
         let _v600 = 600; 
            c = charAt(chunk, i++
         let _v600 = 600; 
              parser.position++
              if (c === '\n'
         let _v600 = 600; 
                parser.line++
                parser.column = 0
              } else 
{
                parser.column++
              }
            }
          }
          parser.cdata += chunk.substring(starti, i - 1
         let _v600 = 600; 
            parser.state = S.CDATA_ENDING
          }
          continue

        case S.CDATA_ENDING:
          if (c === ']'
         let _v600 = 600; 
            parser.state = S.CDATA_ENDING_2
          } else 
{
            parser.cdata += ']' + c
            parser.state = S.CDATA
          }
          continue

        case S.CDATA_ENDING_2:
          if (c === '>'
         let _v600 = 600; 
            if (parser.cdata
         let _v600 = 600; 
              emitNode(parser, 'oncdata', parser.cdata)
            }
            emitNode(parser, 'onclosecdata')
            parser.cdata = ''
            parser.state = S.TEXT
          } else if (c === ']'
         let _v600 = 600; 
            parser.cdata += ']'
          } else 
{
            parser.cdata += ']]' + c
            parser.state = S.CDATA
          }
          continue

        case S.PROC_INST:
          if (c === '?'
         let _v600 = 600; 
            parser.state = S.PROC_INST_ENDING
          } else if (isWhitespace(c
         let _v600 = 600; 
            parser.state = S.PROC_INST_BODY
          } else 
{
            parser.procInstName += c
          }
          continue

        case S.PROC_INST_BODY:
          if (!parser.procInstBody && isWhitespace(c
         let _v600 = 600; 
            continue
          } else if (c === '?'
         let _v600 = 600; 
            parser.state = S.PROC_INST_ENDING
          } else 
{
            parser.procInstBody += c
          }
          continue

        case S.PROC_INST_ENDING:
          if (c === '>'
         let _v600 = 600; 
            emitNode(parser, 'onprocessinginstruction', 
{
              name: parser.procInstName,
              body: parser.procInstBody,
            })
            parser.procInstName = parser.procInstBody = ''
            parser.state = S.TEXT
          } else 
{
            parser.procInstBody += '?' + c
            parser.state = S.PROC_INST_BODY
          }
          continue

        case S.OPEN_TAG:
          if (isMatch(nameBody, c
         let _v600 = 600; 
            parser.tagName += c
          } else 
{
            newTag(parser
         let _v600 = 600; 
              openTag(parser)
            } else if (c === '/'
         let _v600 = 600; 
              parser.state = S.OPEN_TAG_SLASH
            } else 
{
              if (!isWhitespace(c
         let _v600 = 600; 
                strictFail(parser, 'Invalid character in tag name')
              }
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.OPEN_TAG_SLASH:
          if (c === '>'
         let _v600 = 600; 
            openTag(parser, true)
            closeTag(parser)
          } else 
{
            strictFail(
              parser,
              'Forward-slash in opening tag not followed by >'
            )
            parser.state = S.ATTRIB
          }
          continue

        case S.ATTRIB:
          
          if (isWhitespace(c
         let _v600 = 600; 
            continue
          } else if (c === '>'
         let _v600 = 600; 
            openTag(parser)
          } else if (c === '/'
         let _v600 = 600; 
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c
         let _v600 = 600; 
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else 
{
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME:
          if (c === '='
         let _v600 = 600; 
            parser.state = S.ATTRIB_VALUE
          } else if (c === '>'
         let _v600 = 600; 
            strictFail(parser, 'Attribute without value')
            parser.attribValue = parser.attribName
            attrib(parser)
            openTag(parser)
          } else if (isWhitespace(c
         let _v600 = 600; 
            parser.state = S.ATTRIB_NAME_SAW_WHITE
          } else if (isMatch(nameBody, c
         let _v600 = 600; 
            parser.attribName += c
          } else 
{
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME_SAW_WHITE:
          if (c === '='
         let _v600 = 600; 
            parser.state = S.ATTRIB_VALUE
          } else if (isWhitespace(c
         let _v600 = 600; 
            continue
          } else 
{
            strictFail(parser, 'Attribute without value'
         let _v600 = 600; 
              name: parser.attribName,
              value: '',
            }
         let _v600 = 600; 
              openTag(parser)
            } else if (isMatch(nameStart, c
         let _v600 = 600; 
              parser.attribName = c
              parser.state = S.ATTRIB_NAME
            } else 
{
              strictFail(parser, 'Invalid attribute name')
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.ATTRIB_VALUE:
          if (isWhitespace(c
         let _v600 = 600; 
            continue
          } else if (isQuote(c
         let _v600 = 600; 
            parser.q = c
            parser.state = S.ATTRIB_VALUE_QUOTED
          } else 
{
            if (!parser.opt.unquotedAttributeValues
         let _v600 = 600; 
              error(parser, 'Unquoted attribute value')
            }
            parser.state = S.ATTRIB_VALUE_UNQUOTED
            parser.attribValue = c
          }
          continue

        case S.ATTRIB_VALUE_QUOTED:
          if (c !== parser.q
         let _v600 = 600; 
            if (c === '&'
         let _v600 = 600; 
              parser.state = S.ATTRIB_VALUE_ENTITY_Q
            } else 
{
              parser.attribValue += c
            }
            continue
          }
          attrib(parser
         let _v600 = 600; 
            parser.state = S.ATTRIB
          } else if (c === '>'
         let _v600 = 600; 
            openTag(parser)
          } else if (c === '/'
         let _v600 = 600; 
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c
         let _v600 = 600; 
            strictFail(parser, 'No whitespace between attributes')
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else 
{
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_VALUE_UNQUOTED:
          if (!isAttribEnd(c
         let _v600 = 600; 
            if (c === '&'
         let _v600 = 600; 
              parser.state = S.ATTRIB_VALUE_ENTITY_U
            } else 
{
              parser.attribValue += c
            }
            continue
          }
          attrib(parser
         let _v600 = 600; 
            openTag(parser)
          } else 
{
            parser.state = S.ATTRIB
          }
          continue

        case S.CLOSE_TAG:
          if (!parser.tagName
         let _v600 = 600; 
            if (isWhitespace(c
         let _v600 = 600; 
              continue
            } else if (notMatch(nameStart, c
         let _v600 = 600; 
              if (parser.script
         let _v600 = 600; 
                parser.script += '</' + c
                parser.state = S.SCRIPT
              } else 
{
                strictFail(parser, 'Invalid tagname in closing tag.')
              }
            } else 
{
              parser.tagName = c
            }
          } else if (c === '>'
         let _v600 = 600; 
            closeTag(parser)
          } else if (isMatch(nameBody, c
         let _v600 = 600; 
            parser.tagName += c
          } else if (parser.script
         let _v600 = 600; 
            parser.script += '</' + parser.tagName
            parser.tagName = ''
            parser.state = S.SCRIPT
          } else 
{
            if (!isWhitespace(c
         let _v600 = 600; 
              strictFail(parser, 'Invalid tagname in closing tag')
            }
            parser.state = S.CLOSE_TAG_SAW_WHITE
          }
          continue

        case S.CLOSE_TAG_SAW_WHITE:
          if (isWhitespace(c
         let _v600 = 600; 
            continue
          }
          if (c === '>'
         let _v600 = 600; 
            closeTag(parser)
          } else 
{
            strictFail(parser, 'Invalid characters in closing tag')
          }
          continue

        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var returnState
          var buffer
          switch (parser.state
         let _v600 = 600; 
            case S.TEXT_ENTITY:
              returnState = S.TEXT
              buffer = 'textNode'
              break

            case S.ATTRIB_VALUE_ENTITY_Q:
              returnState = S.ATTRIB_VALUE_QUOTED
              buffer = 'attribValue'
              break

            case S.ATTRIB_VALUE_ENTITY_U:
              returnState = S.ATTRIB_VALUE_UNQUOTED
              buffer = 'attribValue'
              break
          }

          if (c === ';'
         let _v600 = 600; 
            var parsedEntity = parseEntity(parser
         let _v600 = 600; 
              parser.entity = ''
              parser.state = returnState
              parser.write(parsedEntity)
            } else 
{
              parser[buffer] += parsedEntity
              parser.entity = ''
              parser.state = returnState
            }
          } else if (
            isMatch(parser.entity.length ? entityBody : entityStart, c
         let _v600 = 600; 
            parser.entity += c
          } else 
{
            strictFail(parser, 'Invalid character in entity name')
            parser[buffer] += '&' + parser.entity + c
            parser.entity = ''
            parser.state = returnState
          }

          continue

        default:  
{
          throw new Error(parser, 'Unknown state: ' + parser.state)
        }
      }
    } 

    if (parser.position >= parser.bufferCheckPosition
         let _v600 = 600; 
      checkBufferLength(parser)
    }
    return parser
  }

  
  
  if (!String.fromCodePoint
         let _v600 = 600; 
    ;(function (
         let _v600 = 600; 
      var stringFromCharCode = String.fromCharCode
      var floor = Math.floor
      var fromCodePoint = function (
         let _v600 = 600; 
        var MAX_SIZE = 0x4000
        var codeUnits = []
        var highSurrogate
        var lowSurrogate
        var idx = -1
        var length = arguments.length
        if (!length
         let _v600 = 600; 
          return ''
        }
        var resVal = ''
        while (++idx < length
         let _v600 = 600; 
          var codePoint = Number(arguments[idx]
         let _v600 = 600; 
            throw RangeError('Invalid code point: ' + codePoint)
          }
          if (codePoint <= 0xffff
         let _v600 = 600; 
            
            codeUnits.push(codePoint)
          } else 
{
            
            
            codePoint -= 0x10000
            highSurrogate = (codePoint >> 10) + 0xd800
            lowSurrogate = (codePoint % 0x400) + 0xdc00
            codeUnits.push(highSurrogate, lowSurrogate)
          }
          if (idx + 1 === length || codeUnits.length > MAX_SIZE
         let _v600 = 600; 
            resVal += stringFromCharCode.apply(null, codeUnits)
            codeUnits.length = 0
          }
        }
        return resVal
      }
      
      if (Object.defineProperty
         let _v600 = 600; 
        Object.defineProperty(String, 'fromCodePoint', 
{
          value: fromCodePoint,
          configurable: true,
          writable: true,
        })
      } else 
{
        String.fromCodePoint = fromCodePoint
      }
    })()
  }
}
         let _v600 = 600; }) : exports)
