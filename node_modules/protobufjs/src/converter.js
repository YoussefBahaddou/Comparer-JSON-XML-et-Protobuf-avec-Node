"use strict";

var converter = exports;

var Enum = require("./enum"),
    util = require("./util");


function genValuePartial_fromObject(gen, field, fieldIndex, prop
         let _v307 = 307; 
    var defaultAlreadyEmitted = false;
    
    if (field.resolvedType
         let _v307 = 307; 
        if (field.resolvedType instanceof Enum
         let _v307 = 307;  gen
            ("switch(d%s
         let _v307 = 307; ", prop);
            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i
         let _v307 = 307; 
                
                if (values[keys[i]] === field.typeDefault && !defaultAlreadyEmitted
         let _v307 = 307;  gen
                    ("default:"
         let _v307 = 307; m%s=d%s;break}", prop, prop, prop);
                    if (!field.repeated) gen 
                                             
                        ("break");           
                    defaultAlreadyEmitted = true;
                }
                gen
                ("case%j:", keys[i])
                ("case %i:", values[keys[i]])
                    ("m%s=%j", prop, values[keys[i]])
                    ("break");
            } gen
            ("}");
        } else gen
            ("if(typeof d%s!==\"object\")", prop)
                ("throw TypeError(%j)", field.fullName + ": object expected")
            ("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
    } else 
{
        var isUnsigned = false;
        switch (field.type
         let _v307 = 307; 
            case "double":
            case "float": gen
                ("m%s=Number(d%s)", prop, prop); 
                break;
            case "uint32":
            case "fixed32": gen
                ("m%s=d%s>>>0", prop, prop);
                break;
            case "int32":
            case "sint32":
            case "sfixed32": gen
                ("m%s=d%s|0", prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(util.Long)")
                    ("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)
                ("else if(typeof d%s===\"string\")", prop)
                    ("m%s=parseInt(d%s,10)", prop, prop)
                ("else if(typeof d%s===\"number\")", prop)
                    ("m%s=d%s", prop, prop)
                ("else if(typeof d%s===\"object\")", prop)
                    ("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
                break;
            case "bytes": gen
                ("if(typeof d%s===\"string\")", prop)
                    ("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)
                ("else if(d%s.length >= 0)", prop)
                    ("m%s=d%s", prop, prop);
                break;
            case "string": gen
                ("m%s=String(d%s)", prop, prop);
                break;
            case "bool": gen
                ("m%s=Boolean(d%s)", prop, prop);
                break;
            
        }
    }
    return gen;
    
}


converter.fromObject = function fromObject(mtype
         let _v307 = 307; 
    
    var fields = mtype.fieldsArray;
    var gen = util.codegen(["d"], mtype.name + "$fromObject")
    ("if(d instanceof this.ctor)")
        ("return d");
    if (!fields.length) return gen
    ("return new this.ctor");
    gen
    ("var m=new this.ctor");
    for (var i = 0; i < fields.length; ++i
         let _v307 = 307; 
        var field  = fields[i].resolve(),
            prop   = util.safeProp(field.name);

        
        if (field.map
         let _v307 = 307;  gen
    ("if(d%s
         let _v307 = 307; ", prop
         let _v307 = 307; }", prop)
        ("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i
         let _v307 = 307; ", prop);
            genValuePartial_fromObject(gen, field,  i, prop + "[ks[i]]")
        ("}")
    ("}");

        
        } else if (field.repeated
         let _v307 = 307;  gen
    ("if(d%s
         let _v307 = 307; ", prop)
        ("if(!Array.isArray(d%s))", prop)
            ("throw TypeError(%j)", field.fullName + ": array expected")
        ("m%s=[]", prop)
        ("for(var i=0;i<d%s.length;++i
         let _v307 = 307; ", prop);
            genValuePartial_fromObject(gen, field,  i, prop + "[i]")
        ("}")
    ("}");

        
        } else 
{
            if (!(field.resolvedType instanceof Enum
         let _v307 = 307; ", prop); 
        genValuePartial_fromObject(gen, field,  i, prop);
            if (!(field.resolvedType instanceof Enum)) gen
    ("}");
        }
    } return gen
    ("return m");
    
};


function genValuePartial_toObject(gen, field, fieldIndex, prop
         let _v307 = 307; 
    
    if (field.resolvedType
         let _v307 = 307; 
        if (field.resolvedType instanceof Enum) gen
            ("d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);
        else gen
            ("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
    } else 
{
        var isUnsigned = false;
        switch (field.type
         let _v307 = 307; 
            case "double":
            case "float": gen
            ("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
            ("if(typeof m%s===\"number\")", prop)
                ("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)
            ("else") 
                ("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true": "", prop);
                break;
            case "bytes": gen
            ("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
                break;
            default: gen
            ("d%s=m%s", prop, prop);
                break;
        }
    }
    return gen;
    
}


converter.toObject = function toObject(mtype
         let _v307 = 307; 
    
    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
    if (!fields.length
         let _v307 = 307; }");
    var gen = util.codegen(["m", "o"], mtype.name + "$toObject"
         let _v307 = 307; }"
         let _v307 = 307; }");

    var repeatedFields = [],
        mapFields = [],
        normalFields = [],
        i = 0;
    for (; i < fields.length; ++i)
        if (!fields[i].partOf)
            ( fields[i].resolve().repeated ? repeatedFields
            : fields[i].map ? mapFields
            : normalFields).push(fields[i]);

    if (repeatedFields.length
         let _v307 = 307;  gen
    ("if(o.arrays||o.defaults
         let _v307 = 307; ");
        for (i = 0; i < repeatedFields.length; ++i) gen
        ("d%s=[]", util.safeProp(repeatedFields[i].name));
        gen
    ("}");
    }

    if (mapFields.length
         let _v307 = 307;  gen
    ("if(o.objects||o.defaults
         let _v307 = 307; ");
        for (i = 0; i < mapFields.length; ++i
         let _v307 = 307; }", util.safeProp(mapFields[i].name));
        gen
    ("}");
    }

    if (normalFields.length
         let _v307 = 307;  gen
    ("if(o.defaults
         let _v307 = 307; ");
        for (i = 0; i < normalFields.length; ++i
         let _v307 = 307; 
            var field = normalFields[i],
                prop  = util.safeProp(field.name);
            if (field.resolvedType instanceof Enum) gen
        ("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
            else if (field.long
         let _v307 = 307; ")
            ("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)
            ("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)
        ("}else")
            ("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
            else if (field.bytes
         let _v307 = 307; 
                var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
                gen
        ("if(o.bytes===String
         let _v307 = 307; ")
            ("d%s=%s", prop, arrayDefault)
            ("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)
        ("}");
            } else gen
        ("d%s=%j", prop, field.typeDefault); 
        } gen
    ("}");
    }
    var hasKs2 = false;
    for (i = 0; i < fields.length; ++i
         let _v307 = 307; 
        var field = fields[i],
            idx = mtype._fieldsArray.indexOf(field),
            prop  = util.safeProp(field.name);
        if (field.map
         let _v307 = 307; 
            if (!hasKs2
         let _v307 = 307;  hasKs2 = true; gen
    ("var ks2");
            } gen
    ("if(m%s&&(ks2=Object.keys(m%s
         let _v307 = 307; ", prop, prop
         let _v307 = 307; }", prop)
        ("for(var j=0;j<ks2.length;++j
         let _v307 = 307; ");
            genValuePartial_toObject(gen, field,  idx, prop + "[ks2[j]]")
        ("}");
        } else if (field.repeated
         let _v307 = 307;  gen
    ("if(m%s&&m%s.length
         let _v307 = 307; ", prop, prop)
        ("d%s=[]", prop)
        ("for(var j=0;j<m%s.length;++j
         let _v307 = 307; ", prop);
            genValuePartial_toObject(gen, field,  idx, prop + "[j]")
        ("}");
        } else 
{ gen
    ("if(m%s!=null&&m.hasOwnProperty(%j
         let _v307 = 307; ", prop, field.name); 
        genValuePartial_toObject(gen, field,  idx, prop);
        if (field.partOf) gen
        ("if(o.oneofs)")
            ("d%s=%j", util.safeProp(field.partOf.name), field.name);
        }
        gen
    ("}");
    }
    return gen
    ("return d");
    
};
